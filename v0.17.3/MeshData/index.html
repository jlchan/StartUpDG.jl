<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MeshData · StartUpDG.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">StartUpDG.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../conventions/">Background and conventions</a></li><li><a class="tocitem" href="../RefElemData/"><code>RefElemData</code></a></li><li class="is-active"><a class="tocitem" href><code>MeshData</code></a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Setting-up-md::MeshData"><span>Setting up <code>md::MeshData</code></span></a></li><li><a class="tocitem" href="#Generating-unstructured-meshes"><span>Generating unstructured meshes</span></a></li><li><a class="tocitem" href="#Initializing-high-order-DG-mesh-data"><span>Initializing high order DG mesh data</span></a></li><li><a class="tocitem" href="#Enforcing-periodic-boundary-conditions"><span>Enforcing periodic boundary conditions</span></a></li><li><a class="tocitem" href="#Creating-curved-meshes"><span>Creating curved meshes</span></a></li><li><a class="tocitem" href="#Unstructured-and-pre-defined-triangular-meshes-using-Triangulate.jl"><span>Unstructured and pre-defined triangular meshes using Triangulate.jl</span></a></li><li><a class="tocitem" href="#Unstructured-curved-quadrilateral-and-hexahedral-meshes-using-HOHQMesh.jl"><span>Unstructured curved quadrilateral and hexahedral meshes using HOHQMesh.jl</span></a></li><li><a class="tocitem" href="#Tagging-boundary-faces-and-boundary-nodes"><span>Tagging boundary faces and boundary nodes</span></a></li></ul></li><li><a class="tocitem" href="../ex_dg_deriv/">Example: computing DG derivatives</a></li><li><a class="tocitem" href="../more_meshes/">Additional mesh types</a></li><li><a class="tocitem" href="../tstep_usage/">Timestepping</a></li><li><a class="tocitem" href="../index_refs/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><code>MeshData</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><code>MeshData</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jlchan/StartUpDG.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MeshData-type"><a class="docs-heading-anchor" href="#MeshData-type"><code>MeshData</code> type</a><a id="MeshData-type-1"></a><a class="docs-heading-anchor-permalink" href="#MeshData-type" title="Permalink"></a></h1><p><a href="../index_refs/#StartUpDG.MeshData"><code>MeshData</code></a> includes fields such as</p><ul><li><code>xyz::NTuple{Dim, ...}</code>: nodal interpolation points mapped to physical elements. All elements of <code>xyz</code> are <span>$N_p \times N_{\rm elements}$</span> matrices, where <span>$N_p$</span> are the number of nodal points on each element.</li><li><code>xyzq::NTuple{Dim, ...}, wJq</code>: volume quadrature points/weights mapped to physical elements. All elements these tuples are <span>$N_q \times N_{\rm elements}$</span> matrices, where <span>$N_q$</span> is the number of quadrature points on each element.</li><li><code>xyzf::NTuple{Dim, ...}</code>: face quadrature points mapped to physical elements. All elements of <code>xyz</code> are <span>$N_f \times N_{\rm elements}$</span> matrices, where <span>$N_f$</span> is the number of face points on each element.</li><li><code>mapP, mapB</code>: indexing arrays for inter-element node connectivity (<code>mapP</code>) and for extracting boundary nodes from the list of face nodes <code>xyzf</code> (<code>mapB</code>). <code>mapP</code> is a matrix of size <span>$N_f \times N_{\rm elements}$</span>, while the length of <code>mapB</code> is the total number of nodes on the boundary.</li><li><code>rstxyzJ::SMatrix{Dim, Dim}</code>: volume geometric terms <span>$G_{ij} = \frac{\partial x_i}{\partial \hat{x}_j}$</span>. Each element of <code>rstxyzJ</code> is a matrix of size <span>$N_p \times N_{\rm elements}$</span>.</li><li><code>J, Jf</code>: volume and surface Jacobians evaluated at interpolation points and surface quadrature points, respectively. <code>J</code> is a matrix of size <span>$N_p \times N_{\rm elements}$</span>, while <code>Jf</code> is a matrix of size <span>$N_f \times N_{\rm elements}$</span>. </li><li><code>nxyz::NTuple{Dim, ...}</code> and <code>nxyzJ::NTuple{Dim, ...}</code>: normalized and <code>Jf</code> scaled outward normals evaluated at surface quadrature points. Each element of <code>nxyzJ</code> is a matrix of size <span>$N_f \times N_{\rm elements}$</span>. </li></ul><p>These are the main quantities used to construct a DG solver. Information specific to the type of mesh used is stored in the <code>md.mesh_type</code> field. </p><h1 id="Setting-up-md::MeshData"><a class="docs-heading-anchor" href="#Setting-up-md::MeshData">Setting up <code>md::MeshData</code></a><a id="Setting-up-md::MeshData-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-md::MeshData" title="Permalink"></a></h1><p>The <a href="../index_refs/#StartUpDG.MeshData"><code>MeshData</code></a> struct contains data for high order DG methods useful for evaluating DG formulations in a matrix-free fashion.</p><h2 id="Generating-unstructured-meshes"><a class="docs-heading-anchor" href="#Generating-unstructured-meshes">Generating unstructured meshes</a><a id="Generating-unstructured-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-unstructured-meshes" title="Permalink"></a></h2><p>For convenience, simple uniform meshes are included in with <code>StartUpDG.jl</code> via <a href="../index_refs/#StartUpDG.uniform_mesh-Tuple{Line, Any}"><code>uniform_mesh</code></a></p><pre><code class="language-julia hljs">using StartUpDG
num_cells_x, num_cells_y, num_cells_z = 4, 2, 8
(VX,), EToV = uniform_mesh(Line(), num_cells_x)
(VX, VY), EToV = uniform_mesh(Tri(), num_cells_x, num_cells_y)
(VX, VY), EToV = uniform_mesh(Quad(), num_cells_x, num_cells_y)
(VX, VY, VZ), EToV = uniform_mesh(Tet(), num_cells_x, num_cells_y, num_cells_z)
(VX, VY, VZ), EToV = uniform_mesh(Pyr(), num_cells_x, num_cells_y, num_cells_z)
(VX, VY, VZ), EToV = uniform_mesh(Wedge(), num_cells_x, num_cells_y, num_cells_z)
(VX, VY, VZ), EToV = uniform_mesh(Hex(), num_cells_x, num_cells_y, num_cells_z)</code></pre><p>The uniform triangular mesh is constructed by creating a uniform quadrilateral mesh then bisecting each quad into two triangles. Wedge meshes are constructed similarly. Tet meshes are constructed by dividing each hexahedron into 5 tetrahedral elements. Pyramid meshes are constructed by dividing each hexahedron into 6 pyramids. </p><h2 id="Initializing-high-order-DG-mesh-data"><a class="docs-heading-anchor" href="#Initializing-high-order-DG-mesh-data">Initializing high order DG mesh data</a><a id="Initializing-high-order-DG-mesh-data-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-high-order-DG-mesh-data" title="Permalink"></a></h2><p>Given unstructured mesh information (tuple of vertex coordinates <code>VXYZ</code> and index array <code>EToV</code>) high order DG mesh data can be constructed as follows:</p><pre><code class="language-julia hljs">md = MeshData(VXYZ, EToV, rd)</code></pre><h2 id="Enforcing-periodic-boundary-conditions"><a class="docs-heading-anchor" href="#Enforcing-periodic-boundary-conditions">Enforcing periodic boundary conditions</a><a id="Enforcing-periodic-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Enforcing-periodic-boundary-conditions" title="Permalink"></a></h2><p>Periodic boundary conditions can be enforced via the <code>is_periodic</code> keyword argument </p><pre><code class="language-julia hljs">md_periodic = MeshData((VX, VY), EToV, rd; is_periodic=true) # periodic in both x and y coordinates
md_periodic_x = MeshData((VX, VY), EToV, rd; is_periodic=(true, false)) # periodic in x direction, but not y</code></pre><p>or by calling <a href="../index_refs/#StartUpDG.make_periodic-Union{Tuple{MeshData{Dim}}, Tuple{Dim}, Tuple{MeshData{Dim}, Bool}} where Dim"><code>make_periodic</code></a>, which returns a new <code>MeshData</code> instance</p><pre><code class="language-julia hljs">md = MeshData((VX, VY), EToV, rd)
md_periodic = make_periodic(md) # periodic in both x and y coordinates
md_periodic_x = make_periodic(md, true, false) # periodic in x direction, but not y</code></pre><p>In either case, the <code>MeshData</code> indexing arrays fields <code>mapP</code>,<code>mapB</code>, and <code>FToF</code> are modified to account for periodicity.</p><p>One can check which dimensions are periodic via the <code>is_periodic</code> field of <code>MeshData</code>. For example, the <code>md_periodic_x</code> example above gives</p><pre><code class="language-julia hljs">julia&gt; md_periodic_x.is_periodic
(true, false)</code></pre><h2 id="Creating-curved-meshes"><a class="docs-heading-anchor" href="#Creating-curved-meshes">Creating curved meshes</a><a id="Creating-curved-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-curved-meshes" title="Permalink"></a></h2><p>It is common to generate curved meshes by first generating a linear mesh, then moving high order nodes on the linear mesh. This can be done by calling <a href="../index_refs/#StartUpDG.MeshData"><code>MeshData</code></a> again with new <code>x, y</code> coordinates:</p><pre><code class="language-julia hljs">md = MeshData((VX, VY), EToV, rd)
(; x, y ) = md
# &lt;-- code to modify high order nodes (x,y)
md_curved = MeshData(rd, md, x, y)</code></pre><p><code>MeshData(rd, md, x, y)</code> and <code>MeshData(rd, md, x, y, z)</code> are implemented for 2D and 3D, though this is not currently implemented in 1D.</p><p>More generally, one can create a copy of a <code>MeshData</code> with certain fields modified by using <code>@set</code> or <code>setproperties</code> from <code>Setfield.jl</code>.</p><h2 id="Unstructured-and-pre-defined-triangular-meshes-using-Triangulate.jl"><a class="docs-heading-anchor" href="#Unstructured-and-pre-defined-triangular-meshes-using-Triangulate.jl">Unstructured and pre-defined triangular meshes using Triangulate.jl</a><a id="Unstructured-and-pre-defined-triangular-meshes-using-Triangulate.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Unstructured-and-pre-defined-triangular-meshes-using-Triangulate.jl" title="Permalink"></a></h2><p>StartUpDG.jl also includes additional utilities based on Triangulate.jl for creating and visualizing meshes. Several pre-defined geometries are included in StartUpDG.jl. A few examples are <code>SquareDomain</code>, <code>RectangularDomainWithHole</code>, <code>Scramjet</code>, and <code>CircularDomain</code>. See <code>triangulate_example_meshes.jl</code> for a more complete list and field arguments. These can each be called using <code>triangulate_domain</code>, for example the following code will create a mesh of a scramjet:</p><pre><code class="language-julia hljs">meshIO = triangulate_domain(Scramjet())
(VX, VY), EToV = triangulateIO_to_VXYEToV(meshIO)
rd = RefElemData(Tri(), 7)
md = MeshData((VX, VY), EToV, rd)</code></pre><p>A quick plot of the face nodes via </p><pre><code class="language-julia hljs">using Plots
scatter(vec.(md.xyzf)..., msw=0, ms=1, aspect_ratio=:equal, ylims=(0,2), leg=false)</code></pre><p>shows the following figure <img src="../assets/scramjet.png" alt="u"/></p><h2 id="Unstructured-curved-quadrilateral-and-hexahedral-meshes-using-HOHQMesh.jl"><a class="docs-heading-anchor" href="#Unstructured-curved-quadrilateral-and-hexahedral-meshes-using-HOHQMesh.jl">Unstructured curved quadrilateral and hexahedral meshes using HOHQMesh.jl</a><a id="Unstructured-curved-quadrilateral-and-hexahedral-meshes-using-HOHQMesh.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Unstructured-curved-quadrilateral-and-hexahedral-meshes-using-HOHQMesh.jl" title="Permalink"></a></h2><p>StartUpDG.jl also reads in <code>.mesh</code> files generated by <a href="https://github.com/trixi-framework/HOHQMesh.jl">HOHQMesh.jl</a>. The following code constructs a <code>MeshData</code> which represents a curved quadrilateral mesh generated by HOHQMesh.jl. </p><pre><code class="language-julia hljs">using StartUpDG
rd = RefElemData(Quad(), 4)
hmd = read_HOHQMesh(&quot;test/testset_HOHQMesh_meshes/easy_example.mesh&quot;)
md = MeshData(hmd, rd)</code></pre><p>We can visualize the mesh using </p><pre><code class="language-julia hljs">using Plots
plot(rd, md) # can also use `plot(MeshPlotter(rd, md))`</code></pre><p>which yields the following figure:</p><p><img src="../assets/hohqmesh.png" alt="u"/></p><p>The boundary faces are also automatically tagged with the labels provided in the HOHQMesh file. Each boundary tag and the faces that lie on it are stored in <code>md.mesh_type.boundary_faces</code>. </p><h2 id="Tagging-boundary-faces-and-boundary-nodes"><a class="docs-heading-anchor" href="#Tagging-boundary-faces-and-boundary-nodes">Tagging boundary faces and boundary nodes</a><a id="Tagging-boundary-faces-and-boundary-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Tagging-boundary-faces-and-boundary-nodes" title="Permalink"></a></h2><p>One can &quot;tag&quot; boundary faces (or boundary nodes) by specifying boolean functions which evaluate to <code>true</code> if a point is on a given boundary segment. </p><pre><code class="language-julia hljs">rd = RefElemData(Tri(), N=3)
md = MeshData(uniform_mesh(Tri(), 1)..., rd)
on_bottom_boundary(point, tol=1e-13) = abs(point[2] + 1) &lt; tol # point = (x,y)
on_top_boundary(point, tol=1e-13) = abs(point[2] - 1) &lt; tol    

boundary_face_dict = tag_boundary_faces(md, Dict(:bottom =&gt; on_bottom_boundary, :top =&gt; on_top_boundary))
boundary_node_dict = tag_boundary_nodes(rd, md, Dict(:bottom =&gt; on_bottom_boundary, :top =&gt; on_top_boundary))</code></pre><p>You can also specify a list of boundaries using NamedTuples </p><pre><code class="language-julia hljs">boundary_face_dict = tag_boundary_faces(md, (; :bottom=&gt;on_bottom_boundary,:top=&gt;on_top_boundary))
boundary_node_dict = tag_boundary_nodes(rd, md, (; :bottom=&gt;on_bottom_boundary,:top=&gt;on_top_boundary))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../RefElemData/">« <code>RefElemData</code></a><a class="docs-footer-nextpage" href="../ex_dg_deriv/">Example: computing DG derivatives »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 29 June 2023 22:56">Thursday 29 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
