<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · StartUpDG.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StartUpDG.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../conventions/">Background and conventions</a></li><li><a class="tocitem" href="../RefElemData/"><code>RefElemData</code></a></li><li><a class="tocitem" href="../MeshData/"><code>MeshData</code></a></li><li><a class="tocitem" href="../ex_dg_deriv/">Example: computing DG derivatives</a></li><li><a class="tocitem" href="../more_meshes/">Additional mesh types</a></li><li><a class="tocitem" href="../tstep_usage/">Timestepping</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../authors/">Authors</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jlchan/StartUpDG.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#StartUpDG.BoundaryTagPlotter"><code>StartUpDG.BoundaryTagPlotter</code></a></li><li><a href="#StartUpDG.CurvedMesh"><code>StartUpDG.CurvedMesh</code></a></li><li><a href="#StartUpDG.CutCellMesh"><code>StartUpDG.CutCellMesh</code></a></li><li><a href="#StartUpDG.MeshData-Tuple{RefElemData, Any, Any}"><code>StartUpDG.MeshData</code></a></li><li><a href="#StartUpDG.MeshData"><code>StartUpDG.MeshData</code></a></li><li><a href="#StartUpDG.MeshImportOptions"><code>StartUpDG.MeshImportOptions</code></a></li><li><a href="#StartUpDG.MeshPlotter"><code>StartUpDG.MeshPlotter</code></a></li><li><a href="#StartUpDG.NamedArrayPartition"><code>StartUpDG.NamedArrayPartition</code></a></li><li><a href="#StartUpDG.NonConformingMesh"><code>StartUpDG.NonConformingMesh</code></a></li><li><a href="#StartUpDG.PhysicalFrame"><code>StartUpDG.PhysicalFrame</code></a></li><li><a href="#StartUpDG.RefElemData-Tuple{Line, Polynomial, Any}"><code>StartUpDG.RefElemData</code></a></li><li><a href="#StartUpDG.RefElemData"><code>StartUpDG.RefElemData</code></a></li><li><a href="#StartUpDG.RefElemData-Tuple{Any}"><code>StartUpDG.RefElemData</code></a></li><li><a href="#StartUpDG.RefElemData-Tuple{Wedge, Polynomial, Any}"><code>StartUpDG.RefElemData</code></a></li><li><a href="#StartUpDG.RefElemData-Tuple{Line, SBP{TensorProductLobatto}, Any}"><code>StartUpDG.RefElemData</code></a></li><li><a href="#StartUpDG.VertexMappedMesh"><code>StartUpDG.VertexMappedMesh</code></a></li><li><a href="#StartUpDG.VertexMeshPlotter"><code>StartUpDG.VertexMeshPlotter</code></a></li><li><a href="#NodesAndModes.equi_nodes-Tuple{PhysicalFrame{2, Shifting, Scaling} where {Shifting&lt;:(StaticArraysCore.SVector{2}), Scaling&lt;:(StaticArraysCore.SVector{2})}, Any, Any}"><code>NodesAndModes.equi_nodes</code></a></li><li><a href="#StartUpDG.MeshData_to_vtk-Union{Tuple{DIM}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any, Any}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any, Any, Any}} where DIM"><code>StartUpDG.MeshData_to_vtk</code></a></li><li><a href="#StartUpDG.SUD_to_vtk_order-Union{Tuple{RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}}, Tuple{DIM}} where DIM"><code>StartUpDG.SUD_to_vtk_order</code></a></li><li><a href="#StartUpDG.boundary_face_centroids-Tuple{Any}"><code>StartUpDG.boundary_face_centroids</code></a></li><li><a href="#StartUpDG.build_node_maps-Tuple{Any, Any}"><code>StartUpDG.build_node_maps</code></a></li><li><a href="#StartUpDG.ck45-Tuple{}"><code>StartUpDG.ck45</code></a></li><li><a href="#StartUpDG.connect_mesh-Tuple{Any, Any, Any}"><code>StartUpDG.connect_mesh</code></a></li><li><a href="#StartUpDG.connect_mesh-Tuple{Any, Any}"><code>StartUpDG.connect_mesh</code></a></li><li><a href="#StartUpDG.estimate_h-Union{Tuple{DIM}, Tuple{RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, MeshData{DIM}}} where DIM"><code>StartUpDG.estimate_h</code></a></li><li><a href="#StartUpDG.findline-Tuple{String, Vector{String}}"><code>StartUpDG.findline</code></a></li><li><a href="#StartUpDG.get_boundary_face_labels-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}}"><code>StartUpDG.get_boundary_face_labels</code></a></li><li><a href="#StartUpDG.get_node_boundary_tags-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}}"><code>StartUpDG.get_node_boundary_tags</code></a></li><li><a href="#StartUpDG.get_num_elements"><code>StartUpDG.get_num_elements</code></a></li><li><a href="#StartUpDG.hybridized_SBP_operators-Tuple{Any}"><code>StartUpDG.hybridized_SBP_operators</code></a></li><li><a href="#StartUpDG.inverse_trace_constant-Tuple{RefElemData{1, Line, Polynomial}}"><code>StartUpDG.inverse_trace_constant</code></a></li><li><a href="#StartUpDG.make_periodic-Union{Tuple{MeshData{Dim}}, Tuple{Dim}, Tuple{MeshData{Dim}, Bool}} where Dim"><code>StartUpDG.make_periodic</code></a></li><li><a href="#StartUpDG.n_verts_between-Tuple{Any, Any, Any}"><code>StartUpDG.n_verts_between</code></a></li><li><a href="#StartUpDG.quad_vtk_order"><code>StartUpDG.quad_vtk_order</code></a></li><li><a href="#StartUpDG.readGmsh2D-Tuple{String}"><code>StartUpDG.readGmsh2D</code></a></li><li><a href="#StartUpDG.readGmsh2D_v4-Tuple{String, MeshImportOptions}"><code>StartUpDG.readGmsh2D_v4</code></a></li><li><a href="#StartUpDG.readGmsh2D_v4"><code>StartUpDG.readGmsh2D_v4</code></a></li><li><a href="#StartUpDG.refine"><code>StartUpDG.refine</code></a></li><li><a href="#StartUpDG.remap_element_grouping-Tuple{Vector{Int64}}"><code>StartUpDG.remap_element_grouping</code></a></li><li><a href="#StartUpDG.sort_by_axis-Tuple{Any}"><code>StartUpDG.sort_by_axis</code></a></li><li><a href="#StartUpDG.tag_boundary_faces-Tuple{Any, Nothing}"><code>StartUpDG.tag_boundary_faces</code></a></li><li><a href="#StartUpDG.tag_boundary_faces-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}, NamedTuple}"><code>StartUpDG.tag_boundary_faces</code></a></li><li><a href="#StartUpDG.triangle_vtk_order"><code>StartUpDG.triangle_vtk_order</code></a></li><li><a href="#StartUpDG.triangulateIO_to_VXYEToV-Tuple{Triangulate.TriangulateIO}"><code>StartUpDG.triangulateIO_to_VXYEToV</code></a></li><li><a href="#StartUpDG.type_to_vtk-Tuple{Wedge}"><code>StartUpDG.type_to_vtk</code></a></li><li><a href="#StartUpDG.type_to_vtk-Tuple{Quad}"><code>StartUpDG.type_to_vtk</code></a></li><li><a href="#StartUpDG.type_to_vtk-Tuple{Tri}"><code>StartUpDG.type_to_vtk</code></a></li><li><a href="#StartUpDG.uniform_mesh-Tuple{Line, Any}"><code>StartUpDG.uniform_mesh</code></a></li><li><a href="#StartUpDG.vtk_order-Tuple{Quad, Any}"><code>StartUpDG.vtk_order</code></a></li><li><a href="#StartUpDG.vtk_order-Tuple{Tri, Any}"><code>StartUpDG.vtk_order</code></a></li><li><a href="#StartUpDG.vtk_order-Tuple{Wedge, Any}"><code>StartUpDG.vtk_order</code></a></li><li><a href="#StartUpDG.wedge_vtk_order-Tuple{Any, Any, Any}"><code>StartUpDG.wedge_vtk_order</code></a></li><li><a href="#Triangulate.triangulate"><code>Triangulate.triangulate</code></a></li></ul><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.BoundaryTagPlotter" href="#StartUpDG.BoundaryTagPlotter"><code>StartUpDG.BoundaryTagPlotter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoundaryTagPlotter(triout::TriangulateIO)</code></pre><p>Plot recipe to visualize boundary tags by color. Usage: <code>plot(BoundaryTagPlotter(triout))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.CurvedMesh" href="#StartUpDG.CurvedMesh"><code>StartUpDG.CurvedMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CurvedMesh</code></pre><p>Mesh type indicating that the mesh has been curved. Stores the original mesh type as a field.</p><p><strong>Fields</strong></p><p>original<em>mesh</em>type :: T<br/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.CutCellMesh" href="#StartUpDG.CutCellMesh"><code>StartUpDG.CutCellMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CutCellMesh</code> is used in the <code>MeshData</code> field <code>mesh_type</code> for cut cell meshes.</p><p>The field <code>physical_frame_elements</code> is a container with shifting/scaling information for  each element. We evaluate the physical basis over each element by applying a shifting and  scaling of the physical coordinates. The resulting shifted/scaled coordinates then fall  into the reference element and can be used to evaluate a reference element basis. </p><p>The field <code>cut_face_nodes</code> is a container whose elements are indices of face nodes for a  cut element. In other words, <code>md.xf.cut[cut_face_nodes[1]]</code> returns the face nodes of the  first element. </p><p>We assume all cut elements have the same number of volume quadrature points (which is at  least the dimension of a degree 2N polynomial space). </p><p>The field <code>objects</code> contains a tuple of the objects used to define the cut region.</p><p>The field <code>cut_cell_operators</code> contains optionally precomputed operators (mass, differntiation,  face interpolation, and lifting operators). </p><p>The field <code>cut_cell_data</code> contains additional data from PathIntersections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.MeshData" href="#StartUpDG.MeshData"><code>StartUpDG.MeshData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MeshData{Dim, Tv, Ti}</code></pre><p>MeshData: contains info for a high order piecewise polynomial discretization on an unstructured mesh. </p><p>Example:</p><pre><code class="language-julia">N, K1D = 3, 2
rd = RefElemData(Tri(), N)
VXY, EToV = uniform_mesh(Tri(), K1D)
md = MeshElemData(VXY, EToV, rd)
(; x, y ) = md</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.MeshData-Tuple{RefElemData, Any, Any}" href="#StartUpDG.MeshData-Tuple{RefElemData, Any, Any}"><code>StartUpDG.MeshData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function MeshData(rd, geometry, vxyz...)</code></pre><p>Creates a cut-cell mesh where the boundary is given by <code>geometry</code>, which should be a tuple of functions.  These functions can be generated using PathIntersections.PresetGeometries, for example:</p><pre><code class="language-julia">julia&gt; geometry = (PresetGeometries.Circle(R=0.33, x0=0, y0=0), )</code></pre><p>Here, <code>coordinates_min</code>, <code>coordinates_max</code> contain <code>(smallest value of x, smallest value of y)</code> and  <code>(largest value of x, largest value of y)</code>, and <code>cells_per_dimension_x/y</code> is the number of Cartesian grid  cells placed along each dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.MeshImportOptions" href="#StartUpDG.MeshImportOptions"><code>StartUpDG.MeshImportOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeshImportOptions</code></pre><p>This struct allows the user to opt for supported features when importing a gmsh 4.1 .msh file.</p><p><strong>Support</strong></p><ul><li>grouping::Bool | On import would you like to include physical group assignements of 2D elements?</li><li>remap_group_name::Bool | On import would you like to maintain or remap physical group ID? Remap results in groupIds in the range 1:number_group_ids.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.MeshPlotter" href="#StartUpDG.MeshPlotter"><code>StartUpDG.MeshPlotter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MeshPlotter(rd::RefElemData, md::RefElemData)</code></pre><p>Plot recipe to plot a (possibly curved) quadrilateral or triangular mesh. Usage: <code>plot(MeshPlotter(...))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.NamedArrayPartition" href="#StartUpDG.NamedArrayPartition"><code>StartUpDG.NamedArrayPartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NamedArrayPartition(; kwargs...)
NamedArrayPartition(x::NamedTuple)</code></pre><p>Similar to an <code>ArrayPartition</code> but the individual arrays can be accessed via the  constructor-specified names. However, unlike <code>ArrayPartition</code>, each individual array  must have the same element type. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.NonConformingMesh" href="#StartUpDG.NonConformingMesh"><code>StartUpDG.NonConformingMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><div class="admonition is-warning"><header class="admonition-header">Experimental implementation</header><div class="admonition-body"><p>This is an experimental feature and may change in future releases.</p></div></div><p>This is a proof of concept implementation of a non-conforming mesh in StartUpDG.jl.  The intended usage is as follows:</p><pre><code class="language-julia">rd = RefElemData(Quad(), N=7)
md = MeshData(NonConformingQuadMeshExample(), rd)

(; x, y ) = md
u = @. sin(pi * x) * sin(pi * y)

# interpolate to faces
num_total_faces = num_faces(rd.element_type) * md.num_elements
u_face = reshape(rd.Vf * u, :, num_total_faces)

# interpolate faces to mortars (`uf` denotes mortar faces for `NonConformingMesh` types)
(; conforming_faces, non_conforming_faces, mortar_interpolation_matrix ) = md.mesh_type
u_mortar = similar(md.xf)
view(u_mortar, :, 1:length(conforming_faces)) .= view(u_face, :, conforming_faces)

# interpolate to non-conforming faces, which are stored after the conforming faces
for (i, f) in enumerate(non_conforming_faces)
    mortar_face_ids = (1:num_mortars_per_face(rd)) .+ (i-1) * num_mortars_per_face(rd) .+ length(conforming_faces)
    u_mortar[:, mortar_face_ids] .= reshape(mortar_interpolation_matrix * u_face[:, f], :, num_mortars_per_face(rd))
end

# get exterior values
uP = u_mortar[md.mapP]</code></pre><p>The <code>mortar_projection_matrix</code> similarly maps values from 2 mortar faces back to values on the  original non-conforming face. These can be used to create DG solvers on non-conforming meshes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.PhysicalFrame" href="#StartUpDG.PhysicalFrame"><code>StartUpDG.PhysicalFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">`PhysicalFrame{NDIMS} &lt;: AbstractElemShape{NDIMS}`</code></pre><p><code>PhysicalFrame</code> element type. Uses a total degree N approximation space, but is  computed with a tensor product Legendre basis as opposed to a triangular PKDO basis. Stores fields <code>shifting</code> and <code>scaling</code> to shift/scale physical coordinates so that  they are on the reference element. </p><pre><code class="language-none">PhysicalFrame()
PhysicalFrame(x, y)
PhysicalFrame(x, y, vx, vy): stores coordinates `vx, vy` of background Cartesian cell</code></pre><p>Constructors for a PhysicalFrame object (optionally uses arrays of points <code>x</code>, <code>y</code> on a cut element).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.RefElemData" href="#StartUpDG.RefElemData"><code>StartUpDG.RefElemData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RefElemData</code></pre><p>RefElemData: contains info (interpolation points, volume/face quadrature, operators) for a high order nodal basis on a given reference element. </p><p>Example:</p><pre><code class="language-julia">N = 3
rd = RefElemData(Tri(), N)
(; r, s ) = rd</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.RefElemData-Tuple{Any}" href="#StartUpDG.RefElemData-Tuple{Any}"><code>StartUpDG.RefElemData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function RefElemData(elem; N, kwargs...)
function RefElemData(elem, approxType; N, kwargs...)</code></pre><p>Keyword argument constructor for RefElemData (to &quot;label&quot; <code>N</code> via <code>rd = RefElemData(Line(), N=3)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.RefElemData-Tuple{Line, Polynomial, Any}" href="#StartUpDG.RefElemData-Tuple{Line, Polynomial, Any}"><code>StartUpDG.RefElemData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RefElemData(elem::Line, N;
            quad_rule_vol = quad_nodes(elem, N+1))
RefElemData(elem::Union{Tri, Quad}, N;
             quad_rule_vol = quad_nodes(elem, N),
             quad_rule_face = gauss_quad(0, 0, N))
RefElemData(elem::Union{Hex, Tet}, N;
             quad_rule_vol = quad_nodes(elem, N),
             quad_rule_face = quad_nodes(Quad(), N))
RefElemData(elem; N, kwargs...) # version with keyword args</code></pre><p>Constructor for <code>RefElemData</code> for different element types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.RefElemData-Tuple{Line, SBP{TensorProductLobatto}, Any}" href="#StartUpDG.RefElemData-Tuple{Line, SBP{TensorProductLobatto}, Any}"><code>StartUpDG.RefElemData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function RefElemData(elementType::Line, approxType::SBP, N)
function RefElemData(elementType::Quad, approxType::SBP, N)
function RefElemData(elementType::Hex,  approxType::SBP, N)
function RefElemData(elementType::Tri,  approxType::SBP, N)</code></pre><p>SBP reference element data for <code>Quad()</code>, <code>Hex()</code>, and <code>Tri()</code> elements. </p><p>For <code>Line()</code>, <code>Quad()</code>, and <code>Hex()</code>, <code>approxType</code> is <code>SBP{TensorProductLobatto}</code>.</p><p>For <code>Tri()</code>, <code>approxType</code> can be <code>SBP{Kubatko{LobattoFaceNodes}}</code>, <code>SBP{Kubatko{LegendreFaceNodes}}</code>, or <code>SBP{Hicken}</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.RefElemData-Tuple{Wedge, Polynomial, Any}" href="#StartUpDG.RefElemData-Tuple{Wedge, Polynomial, Any}"><code>StartUpDG.RefElemData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RefElemData(elem::Wedge, approximation_type::Polynomial, N;
            quad_rule_vol=quad_nodes(elem, N),
            quad_rule_face_quad=quad_nodes(Quad(), N), 
            quad_rule_face_tri=quad_nodes(Tri(), N), 
            quad_rule_face=(quad_rule_face_quad, quad_rule_face_tri),
            Nplot=10)</code></pre><p>Builds operators for prisms/wedges</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.VertexMappedMesh" href="#StartUpDG.VertexMappedMesh"><code>StartUpDG.VertexMappedMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct VertexMappedMesh</code></pre><p>The default <code>MeshData</code> mesh type, represents a mesh which is defined purely by  vertex locations and element-to-vertex connectivities. For example, these include  affine triangular meshes or bilinear quadrilateral or trilinear hexahedral meshes.</p><p><strong>Fields</strong></p><p>element_type :: TE &lt;: AbstractElemShape <br/>VXYZ :: TV <br/>EToV :: TEV</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.VertexMeshPlotter" href="#StartUpDG.VertexMeshPlotter"><code>StartUpDG.VertexMeshPlotter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VertexMeshPlotter((VX, VY), EToV, fv)
VertexMeshPlotter(triout::TriangulateIO)</code></pre><p>Plot recipe to plot a quadrilateral or triangular mesh. Usage: <code>plot(VertexMeshPlotter(...))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NodesAndModes.equi_nodes-Tuple{PhysicalFrame{2, Shifting, Scaling} where {Shifting&lt;:(StaticArraysCore.SVector{2}), Scaling&lt;:(StaticArraysCore.SVector{2})}, Any, Any}" href="#NodesAndModes.equi_nodes-Tuple{PhysicalFrame{2, Shifting, Scaling} where {Shifting&lt;:(StaticArraysCore.SVector{2}), Scaling&lt;:(StaticArraysCore.SVector{2})}, Any, Any}"><code>NodesAndModes.equi_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function NodesAndModes.equi_nodes(elem::PhysicalFrame, curve, N)</code></pre><p>Returns back <code>Np(N)</code> equally spaced nodes on the background quadrilateral corresponding  to <code>elem</code>, with points inside of <code>curve</code> removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.MeshData_to_vtk-Union{Tuple{DIM}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any, Any}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any, Any, Any}} where DIM" href="#StartUpDG.MeshData_to_vtk-Union{Tuple{DIM}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any, Any}, Tuple{MeshData, RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, Any, Any, Any, Any, Any}} where DIM"><code>StartUpDG.MeshData_to_vtk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MeshData_to_vtk(md, rd, dim, data, dataname, datatype, filename, write_data = false, equi_dist_nodes = true)</code></pre><p>Translate the given mesh into a vtk-file. <code>md</code> holds a <code>MeshData</code> object <code>rd</code> holds a reference element data/<code>RefElemData</code> object.  <code>data</code> holds an array of arrays (of size <code>num_nodes</code> by <code>num_elements</code>) with plotting data <code>dataname</code> is an array of strings with name of the associated data <code>write_data</code>, flag if data should be written or not (e.g., if data is not written, only the mesh will be saved as output) <code>equi_dist_nodes</code> flag if points should be interpolated to equidstant nodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.SUD_to_vtk_order-Union{Tuple{RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}}, Tuple{DIM}} where DIM" href="#StartUpDG.SUD_to_vtk_order-Union{Tuple{RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}}, Tuple{DIM}} where DIM"><code>StartUpDG.SUD_to_vtk_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SUD_to_vtk_order(rd::RefElemData, dim)</code></pre><p>Compute the permutation of the nodes between StartUpDG and VTK</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.boundary_face_centroids-Tuple{Any}" href="#StartUpDG.boundary_face_centroids-Tuple{Any}"><code>StartUpDG.boundary_face_centroids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function boundary_face_centroids(md)</code></pre><p>Returns face centroids and <code>boundary_face_ids</code> on the boundaries of the domain given by md::MeshData.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.build_node_maps-Tuple{Any, Any}" href="#StartUpDG.build_node_maps-Tuple{Any, Any}"><code>StartUpDG.build_node_maps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build_node_maps(FToF, Xf)</code></pre><p>Intialize the connectivity table along all edges and boundary node tables of all elements. <code>mapM</code> - map minus (interior). <code>mapP</code> - map plus (exterior).</p><p><code>Xf = (xf, yf, zf)</code> and <code>FToF</code> is size <code>(Nfaces * K)</code> and <code>FToF[face]</code> = face neighbor</p><p><code>mapM</code>, <code>mapP</code> are size <code>Nfp</code> x <code>(Nfaces*K)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; mapM, mapP, mapB = build_node_maps(FToF, (xf, yf))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.ck45-Tuple{}" href="#StartUpDG.ck45-Tuple{}"><code>StartUpDG.ck45</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ck45()</code></pre><p>Returns coefficients rka,rkb,rkc for the 4th order 5-stage low storage Carpenter/Kennedy Runge Kutta method. Coefficients evolve the residual, solution, and local time, e.g.,</p><p><strong>Example</strong></p><pre><code class="language-julia">res = rk4a[i]*res + dt*rhs # i = RK stage
@. u += rk4b[i]*res</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.connect_mesh-Tuple{Any, Any, Any}" href="#StartUpDG.connect_mesh-Tuple{Any, Any, Any}"><code>StartUpDG.connect_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connect_mesh(rd, face_centroids, region_flags, cutcells; tol = 1e2 * eps())</code></pre><p>Connects faces of a cut mesh to each other, returns <code>FToF</code> such that face  <code>f</code> is connected to <code>FToF[f]</code>. </p><p>Inputs:</p><ul><li>rd::RefElemData</li><li>face<em>centroids = (face</em>centroids<em>x, face</em>centroids<em>y), where `face</em>centroids_x/y`                    are vectors of coordinates of face centroids</li><li><code>region_flags</code>, <code>cutcells</code> are return arguments from <code>PathIntersections.define_regions</code></li></ul><p>The keyword argument <code>tol</code> is the tolerance for matches between face centroids. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.connect_mesh-Tuple{Any, Any}" href="#StartUpDG.connect_mesh-Tuple{Any, Any}"><code>StartUpDG.connect_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connect_mesh(EToV,fv)</code></pre><p>Inputs:</p><ul><li><code>EToV</code> is a <code>num_elements</code> by <code>Nv</code> matrix whose rows identify the <code>Nv</code> vertices</li></ul><p>which make up one of the <code>num_elements</code> elements.</p><ul><li><code>fv</code> (an array of arrays containing unordered indices of face vertices).</li></ul><p>Output: <code>FToF</code>, an <code>length(fv)</code> by <code>num_elements</code> index array containing  face-to-face connectivity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.estimate_h-Union{Tuple{DIM}, Tuple{RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, MeshData{DIM}}} where DIM" href="#StartUpDG.estimate_h-Union{Tuple{DIM}, Tuple{RefElemData{DIM, ElemShape} where ElemShape&lt;:AbstractElemShape{DIM}, MeshData{DIM}}} where DIM"><code>StartUpDG.estimate_h</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimate_h(rd::RefElemData, md::MeshData)
estimate_h(e, rd::RefElemData, md::MeshData) # e = element index</code></pre><p>Estimates the mesh size via min size<em>of</em>domain * |J|/|Jf|, since |J| = O(hᵈ) and |Jf| = O(hᵈ⁻¹). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.findline-Tuple{String, Vector{String}}" href="#StartUpDG.findline-Tuple{String, Vector{String}}"><code>StartUpDG.findline</code></a> — <span class="docstring-category">Method</span></header><section><div><p>findline(word::String, lines)</p><p>Outputs the line number of <code>word</code> in <code>lines</code>. </p><p>It is assumed that the word exists at least once in the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.get_boundary_face_labels-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}}" href="#StartUpDG.get_boundary_face_labels-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}}"><code>StartUpDG.get_boundary_face_labels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function get_boundary_face_labels(triout::TriangulateIO, md::MeshData{2})</code></pre><p>Find Triangle segment labels of boundary faces. Returns two arguments:</p><ul><li><code>boundary_face_tags</code>: tags of faces on the boundary</li><li><code>boundary_faces</code>: list of faces on the boundary of the domain</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.get_node_boundary_tags-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}}" href="#StartUpDG.get_node_boundary_tags-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}}"><code>StartUpDG.get_node_boundary_tags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function get_node_boundary_tags(triout::TriangulateIO,md::MeshData{2},rd::RefElemData{2,Tri})</code></pre><p>Computes <code>node_tags</code> = <code>Nfp</code> x <code>Nfaces * num_elements</code> array where each entry is a Triangulate.jl tag number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.get_num_elements" href="#StartUpDG.get_num_elements"><code>StartUpDG.get_num_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><p>returns the number of elements in a .msh file of a specified dimension</p><p><strong>Notes: Gmsh includes elements in a .msh file of multiple dimensions. We want a count of how many</strong></p><p>2D elements are in our file. This corisponds to the number of elements in our tri mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.hybridized_SBP_operators-Tuple{Any}" href="#StartUpDG.hybridized_SBP_operators-Tuple{Any}"><code>StartUpDG.hybridized_SBP_operators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function hybridized_SBP_operators(rd::RefElemData{DIMS})</code></pre><p>Constructs hybridized SBP operators given a <code>RefElemData</code>. Returns operators <code>Qrsth..., VhP, Ph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.inverse_trace_constant-Tuple{RefElemData{1, Line, Polynomial}}" href="#StartUpDG.inverse_trace_constant-Tuple{RefElemData{1, Line, Polynomial}}"><code>StartUpDG.inverse_trace_constant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function inverse_trace_constant(rd::RefElemData)</code></pre><p>Returns the degree-dependent constant in the inverse trace equality over the reference element (as reported in <a href="https://doi.org/10.1016/j.jcp.2016.04.003">&quot;GPU-accelerated dG methods on hybrid meshes&quot;</a> by Chan, Wang, Modave, Remacle, Warburton 2016).</p><p>Can be used to estimate dependence of maximum stable timestep on degree of approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.make_periodic-Union{Tuple{MeshData{Dim}}, Tuple{Dim}, Tuple{MeshData{Dim}, Bool}} where Dim" href="#StartUpDG.make_periodic-Union{Tuple{MeshData{Dim}}, Tuple{Dim}, Tuple{MeshData{Dim}, Bool}} where Dim"><code>StartUpDG.make_periodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make_periodic(md::MeshData{Dim}, is_periodic...) where {Dim}
make_periodic(md::MeshData{Dim}, is_periodic = ntuple(x-&gt;true,Dim)) where {Dim}
make_periodic(md::MeshData, is_periodic = true)</code></pre><p>Returns new MeshData such that the node maps <code>mapP</code> and face maps <code>FToF</code> are now periodic. Here, <code>is_periodic</code> is a tuple of <code>Bool</code> indicating whether or not to impose periodic BCs in the <code>x</code>,<code>y</code>, or <code>z</code> coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.n_verts_between-Tuple{Any, Any, Any}" href="#StartUpDG.n_verts_between-Tuple{Any, Any, Any}"><code>StartUpDG.n_verts_between</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">n_verts_between(n, from, to, dim)</code></pre><p>Compute the coordinates of n equally distributed points between the points given by <code>from</code> and <code>to</code>. <code>dim</code> is the dimension of <code>from</code> and <code>to</code>.  Inspired by: https://github.com/ju-kreber/paraview-scripts/blob/master/node_ordering.py</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.quad_vtk_order" href="#StartUpDG.quad_vtk_order"><code>StartUpDG.quad_vtk_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quad_vtk_order(corner_verts, order, dim, skip = false)</code></pre><p>Compute the coordinates of a VTK<em>LAGRANGE</em>QUAD of a quad of order <code>order</code> defined by the coordinates of the vertices given in <code>corner_verts</code>. <code>dim</code> is the dimension of the coordinates given. If <code>skip</code> is set to true, the coordinates of the vertex- and edge-points aren&#39;t computed, which can be used to compute points of a <code>VTK_LAGRANGE_WEDGE</code> Inspired by: https://github.com/ju-kreber/paraview-scripts/blob/master/node_ordering.py</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.readGmsh2D-Tuple{String}" href="#StartUpDG.readGmsh2D-Tuple{String}"><code>StartUpDG.readGmsh2D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function readGmsh2D(filename) reads triangular GMSH 2D file format 2.2 0 8. returns (VX, VY), EToV</p><p><strong>Examples</strong></p><pre><code class="language-julia">VXY, EToV = readGmsh2D(&quot;eulerSquareCylinder2D.msh&quot;)</code></pre><p>https://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format-version-2-<em>0028Legacy</em>0029</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.readGmsh2D_v4" href="#StartUpDG.readGmsh2D_v4"><code>StartUpDG.readGmsh2D_v4</code></a> — <span class="docstring-category">Function</span></header><section><div><p>For brevity while grouping is the only supported feature this allows for simpler code     example: VXY, EToV, grouping = readGmsh2D<em>v4(&quot;file.msh&quot;,true)     example: VXY, EToV = readGmsh2D</em>v4(&quot;file.msh&quot;,false)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.readGmsh2D_v4-Tuple{String, MeshImportOptions}" href="#StartUpDG.readGmsh2D_v4-Tuple{String, MeshImportOptions}"><code>StartUpDG.readGmsh2D_v4</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function readGmsh2D_v4(filename)</p><p>reads triangular GMSH 2D .msh files.</p><p><strong>Output</strong></p><p>This depends on if grouping is opted for or not</p><ul><li>returns: (VX,VY), EToV</li><li>return:(VX,VY),EToV,grouping</li></ul><p><strong>Supported formats and features:</strong></p><ul><li>version 4.1   &#39;physical group support   &#39;remap group ids</li></ul><p><strong>grouping application</strong></p><p>When modeling the wave equation you might want wave speeds to vary accross your domain. By assigning Physical groups in gmsh we can maintain such groupings upon importing the .msh file. Each imported element will be a member of a phyical group.</p><pre><code class="language-julia">VXY, EToV = readGmsh2D_v4(&quot;eulerSquareCylinder2D.msh&quot;)
VXY, EToV = readGmsh2D_v4(&quot;eulerSquareCylinder2D.msh&quot;,false)
VXY, EToV, grouping = readGmsh2D_v4(&quot;eulerSquareCylinder2D.msh&quot;, true)

option = MeshOption(true)
VXY, EToV, grouping = readGmsh2D_v4(&quot;eulerSquareCylinder2D.msh&quot;, option)</code></pre><p>https://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format</p><p>Notes:The version 4 format has a more detailed block data format this leads to more complicated parser.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.refine" href="#StartUpDG.refine"><code>StartUpDG.refine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function refine(triout, h, href = h/2)</code></pre><p>Refinement of a previous mesh given the current mesh size <code>h</code>. Preserves boundary/volume tags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.remap_element_grouping-Tuple{Vector{Int64}}" href="#StartUpDG.remap_element_grouping-Tuple{Vector{Int64}}"><code>StartUpDG.remap_element_grouping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>remap<em>element</em>grouping!(eg::Vector{Int}) GMSH uses integers for naming conventions. This function remaps the gmsh ids to a list of ids 1:numGroups. This just cleans up a little after Gmsh</p><p><strong>Example output</strong></p><p>remap<em>element</em>grouping([16,16,17,17]) -&gt; [1,1,2,2]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.sort_by_axis-Tuple{Any}" href="#StartUpDG.sort_by_axis-Tuple{Any}"><code>StartUpDG.sort_by_axis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_by_axis(corner_verts)</code></pre><p>Given the points &#39;corner_verts&#39; sort them in a lexicographical order and return the permutated points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.tag_boundary_faces-Tuple{Any, Nothing}" href="#StartUpDG.tag_boundary_faces-Tuple{Any, Nothing}"><code>StartUpDG.tag_boundary_faces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function tag_boundary_faces(md, boundary_name::Symbol = :entire_boundary)
function tag_boundary_faces(md, boundary_list::Dict{Symbol, &lt;:Function})</code></pre><p>When called without arguments, just returns <code>Dict(:entire_boundary =&gt; boundary_faces)</code>`.</p><p>Example usage: </p><pre><code class="language-julia">julia&gt; rd = RefElemData(Tri(), N=1)
julia&gt; md = MeshData(uniform_mesh(Tri(), 2)..., rd)
julia&gt; on_bottom_boundary(x, y, tol = 1e-13) = abs(y+1) &lt; tol
julia&gt; on_top_boundary(x, y, tol = 1e-13) = abs(y-1) &lt; tol
julia&gt; tag_boundary_faces(Dict(:bottom =&gt; on_bottom_boundary,
                               :top    =&gt; on_top_boundary), md)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.tag_boundary_faces-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}, NamedTuple}" href="#StartUpDG.tag_boundary_faces-Tuple{Triangulate.TriangulateIO, RefElemData{2, Tri}, MeshData{2}, NamedTuple}"><code>StartUpDG.tag_boundary_faces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function tag_boundary_faces(triout::TriangulateIO,
                            rd::RefElemData{2,Tri}, md::MeshData{2},
                            boundary_list::Union{NamedTuple,Dict{Symbol,Int}})</code></pre><p>Here, <code>boundary_list</code> is a <code>Dict</code> (or <code>NamedTuple</code>) whose values are the boundary tags for a <code>TriangulateIO</code> mesh format. The output is a <code>Dict</code> or <code>NamedTuple</code> with keys given by <code>boundary_list</code> and <code>values</code> equal to vectors of faces on that given boundary.</p><p>Example usage:</p><pre><code class="language-julia">julia&gt; using Triangulate, StartUpDG
julia&gt; triout = scramjet()
julia&gt; rd = RefElemData(Tri(),N=1)
julia&gt; md = MeshData(triangulateIO_to_VXYEToV(triout)...,rd)
julia&gt; tag_boundary_faces(triout,rd,md, Dict(:wall=&gt;1, :inflow=&gt;2, :outflow=&gt;3))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.triangle_vtk_order" href="#StartUpDG.triangle_vtk_order"><code>StartUpDG.triangle_vtk_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">triangle_vtk_order(corner_verts, order, dim, skip = false)</code></pre><p>Compute the coordinates of a <code>VTK_LAGRANGE_TRIANGLE</code> of a triangle or order <code>order</code>  defined by the coordinates of the vertices given in <code>corner_verts</code>. <code>dim</code> is the dimension of the coordinates given. If <code>skip</code> is set to true, the coordinates of the vertex- and edge-points aren&#39;t computed, which can be used to compute points of a <code>VTK_LAGRANGE_WEDGE</code> Inspired by: https://github.com/ju-kreber/paraview-scripts/blob/master/node_ordering.py</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.triangulateIO_to_VXYEToV-Tuple{Triangulate.TriangulateIO}" href="#StartUpDG.triangulateIO_to_VXYEToV-Tuple{Triangulate.TriangulateIO}"><code>StartUpDG.triangulateIO_to_VXYEToV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function triangulateIO_to_VXYEToV(triout::TriangulateIO)</code></pre><p>Computes <code>VX</code>,<code>VY</code>,<code>EToV</code> from a <code>TriangulateIO</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.type_to_vtk-Tuple{Quad}" href="#StartUpDG.type_to_vtk-Tuple{Quad}"><code>StartUpDG.type_to_vtk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">type_to_vtk(elem::Quad)
return the VTK-type</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.type_to_vtk-Tuple{Tri}" href="#StartUpDG.type_to_vtk-Tuple{Tri}"><code>StartUpDG.type_to_vtk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">type_to_vtk(elem::Tri)
return the VTK-type</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.type_to_vtk-Tuple{Wedge}" href="#StartUpDG.type_to_vtk-Tuple{Wedge}"><code>StartUpDG.type_to_vtk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">type_to_vtk(elem::Wedge)
return the VTK-type</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.uniform_mesh-Tuple{Line, Any}" href="#StartUpDG.uniform_mesh-Tuple{Line, Any}"><code>StartUpDG.uniform_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uniform_mesh(elem::Line,Kx)
uniform_mesh(elem::Tri,Kx,Ky)
uniform_mesh(elem::Quad,Kx,Ky)
uniform_mesh(elem::Hex,Kx,Ky,Kz)
uniform_mesh(elem, K)</code></pre><p>Uniform <code>Kx</code> (by <code>Ky</code> by <code>Kz</code>) mesh on <span>$[-1,1]^d$</span>, where <code>d</code> is the spatial dimension. Returns <code>(VX,VY,VZ)</code>, <code>EToV</code>. When only one <code>K</code> is specified, it assumes a uniform mesh with <code>K</code> elements in each coordinate direction.</p><p><code>K</code> can also be specified using a keyword argument <code>K1D</code>, e.g., <code>uniform_mesh(elem; K1D = 16)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.vtk_order-Tuple{Quad, Any}" href="#StartUpDG.vtk_order-Tuple{Quad, Any}"><code>StartUpDG.vtk_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vtk_order(elem::Quad, order)</code></pre><p>Construct all node-points of a VTK<em>LAGRANGE</em>QUAD of order <code>order</code>. The corner-nodes are given by the reference quadrilateral used by StartUpDG in the order defined by vtk</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.vtk_order-Tuple{Tri, Any}" href="#StartUpDG.vtk_order-Tuple{Tri, Any}"><code>StartUpDG.vtk_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vtk_order(elem::Tri, order)</code></pre><p>Construct all node-points of a <code>VTK_LAGRANGE_TRIANGLE</code> of order <code>order</code>. The corner-nodes are given by the reference-triangle used by StartUpDG in the order defined by vtk</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.vtk_order-Tuple{Wedge, Any}" href="#StartUpDG.vtk_order-Tuple{Wedge, Any}"><code>StartUpDG.vtk_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vtk_order(elem::Wedge, order)</code></pre><p>Construct all node-points of a VTK<em>LAGRANGE</em>WEDGE of order <code>order</code>. The corner-nodes are given by the reference-wedge used by StartUpDG</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StartUpDG.wedge_vtk_order-Tuple{Any, Any, Any}" href="#StartUpDG.wedge_vtk_order-Tuple{Any, Any, Any}"><code>StartUpDG.wedge_vtk_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wedge_vtk_order(corner_verts, order, dim)</code></pre><p>Compute the coordinates of a VTK<em>LAGRANGE</em>WEDGE of order <code>order</code>  defined by the coordinates of the vertices given in <code>corner_verts</code>. <code>dim</code> is the dimension of the coordinates given.  Inspired by: https://github.com/ju-kreber/paraview-scripts/blob/master/node_ordering.py</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Triangulate.triangulate" href="#Triangulate.triangulate"><code>Triangulate.triangulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function Triangulate.triangulate(triin::TriangulateIO, maxarea, minangle=20)</code></pre><p>Convenience routine to avoid writing out <code>@sprintf</code> each time. Returns a <code>TriangulateIO</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlchan/StartUpDG.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tstep_usage/">« Timestepping</a><a class="docs-footer-nextpage" href="../authors/">Authors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 28 March 2023 02:32">Tuesday 28 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
